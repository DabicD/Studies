//--------------------------------------------------------------------------------
// Code generated by jFuzzyLogic
// jFuzzyLogic Version : JFuzzyLogic 3.3 (build 2015-04-09), by Pablo Cingolani
// jFuzzyLogic creted by Pablo Cingolani
//--------------------------------------------------------------------------------

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
double ruleAccumulationMethod_max(double defuzzifierValue, double valueToAggregate)	{ return ( defuzzifierValue > valueToAggregate ? defuzzifierValue : valueToAggregate ); }

double ruleActivationMethod_min(double degreeOfSupport, double membership)	{ return (degreeOfSupport < membership ? degreeOfSupport : membership); }

double ruleConnectionMethod_and(double antecedent1, double antecedent2)	{ return (antecedent1 < antecedent2 ? antecedent1 : antecedent2); }

class FunctionBlock_crashchance {

	public:
	// VAR_INPUT
	double distance;

	// VAR_OUTPUT
	double sugested;

	private:
	// FUZZIFY distance
	double distance_decent;
	double distance_far;
	double distance_faraway;
	double distance_nearby;
	double distance_verynearby;


	// DEFUZZIFY sugested
	double defuzzify_sugested[1000];


	public:
	FunctionBlock_crashchance();
	void calc();
	void print();

	private:
	void defuzzify();
	void fuzzify();
	void reset();
	double membership_distance_decent(double x);
	double membership_distance_far(double x);
	double membership_distance_faraway(double x);
	double membership_distance_nearby(double x);
	double membership_distance_verynearby(double x);
	double membership_sugested_decent(double x);
	double membership_sugested_fast(double x);
	double membership_sugested_slow(double x);
	double membership_sugested_veryfast(double x);
	double membership_sugested_veryslow(double x);
	void calc_No1();

};

// Constructor
FunctionBlock_crashchance::FunctionBlock_crashchance() {
	sugested = 0.0;
}

// Calculate function block
void FunctionBlock_crashchance::calc() {
	reset();
	fuzzify();
	calc_No1();
	defuzzify();
}

// RULEBLOCK No1
void FunctionBlock_crashchance::calc_No1() {
	// RULE 1 : IF distance IS verynearby THEN sugested IS veryslow;
	double degreeOfSupport_1 = 1.0 * ( distance_verynearby );
	if( degreeOfSupport_1 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = 0.0 + i * 0.12;
			double membership = membership_sugested_veryslow(x);
			double y = ruleActivationMethod_min( degreeOfSupport_1 , membership );
			defuzzify_sugested[i] += ruleAccumulationMethod_max( defuzzify_sugested[i], y );
		}
	}

	// RULE 2 : IF distance IS nearby THEN sugested IS slow;
	double degreeOfSupport_2 = 1.0 * ( distance_nearby );
	if( degreeOfSupport_2 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = 0.0 + i * 0.12;
			double membership = membership_sugested_slow(x);
			double y = ruleActivationMethod_min( degreeOfSupport_2 , membership );
			defuzzify_sugested[i] += ruleAccumulationMethod_max( defuzzify_sugested[i], y );
		}
	}

	// RULE 3 : IF distance IS decent THEN sugested IS decent;
	double degreeOfSupport_3 = 1.0 * ( distance_decent );
	if( degreeOfSupport_3 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = 0.0 + i * 0.12;
			double membership = membership_sugested_decent(x);
			double y = ruleActivationMethod_min( degreeOfSupport_3 , membership );
			defuzzify_sugested[i] += ruleAccumulationMethod_max( defuzzify_sugested[i], y );
		}
	}

	// RULE 4 : IF distance IS far THEN sugested IS fast;
	double degreeOfSupport_4 = 1.0 * ( distance_far );
	if( degreeOfSupport_4 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = 0.0 + i * 0.12;
			double membership = membership_sugested_fast(x);
			double y = ruleActivationMethod_min( degreeOfSupport_4 , membership );
			defuzzify_sugested[i] += ruleAccumulationMethod_max( defuzzify_sugested[i], y );
		}
	}

	// RULE 5 : IF distance IS faraway THEN sugested IS veryfast;
	double degreeOfSupport_5 = 1.0 * ( distance_faraway );
	if( degreeOfSupport_5 > 0 ) {
		for (int i = 0 ; i < 1000 ; i++ ) {
			double x = 0.0 + i * 0.12;
			double membership = membership_sugested_veryfast(x);
			double y = ruleActivationMethod_min( degreeOfSupport_5 , membership );
			defuzzify_sugested[i] += ruleAccumulationMethod_max( defuzzify_sugested[i], y );
		}
	}

}

// Defuzzify
void FunctionBlock_crashchance::defuzzify() {
	double sum_sugested = 0.0;
	double wsum_sugested = 0.0;
	for (int i = 0; i < 1000 ; i++ ) {
		double x = 0.0 + i * 0.12;
		sum_sugested += defuzzify_sugested[i];
		wsum_sugested += x * defuzzify_sugested[i];
	}
	sugested = wsum_sugested / sum_sugested;
}

// Fuzzify all variables
void FunctionBlock_crashchance::fuzzify() {
	distance_decent = membership_distance_decent(distance);
	distance_far = membership_distance_far(distance);
	distance_faraway = membership_distance_faraway(distance);
	distance_nearby = membership_distance_nearby(distance);
	distance_verynearby = membership_distance_verynearby(distance);
}

// Membership functions
double FunctionBlock_crashchance::membership_distance_decent(double x) {
	if ( x <= 80.0 )	return 0.0;
	if ( x > 250.0 )	return 0.0;
	if ( x <= 100.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 80.0 ) / ( 100.0 - 80.0 ) );
	if ( x <= 200.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 100.0 ) / ( 200.0 - 100.0 ) );
	if ( x <= 250.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 200.0 ) / ( 250.0 - 200.0 ) );
}

double FunctionBlock_crashchance::membership_distance_far(double x) {
	if ( x <= 200.0 )	return 0.0;
	if ( x > 500.0 )	return 0.0;
	if ( x <= 250.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 200.0 ) / ( 250.0 - 200.0 ) );
	if ( x <= 400.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 250.0 ) / ( 400.0 - 250.0 ) );
	if ( x <= 500.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 400.0 ) / ( 500.0 - 400.0 ) );
}

double FunctionBlock_crashchance::membership_distance_faraway(double x) {
	if ( x <= 450.0 )	return 0.0;
	if ( x > 1000.0 )	return 1.0;
	if ( x <= 650.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 450.0 ) / ( 650.0 - 450.0 ) );
	if ( x <= 1000.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 650.0 ) / ( 1000.0 - 650.0 ) );
}

double FunctionBlock_crashchance::membership_distance_nearby(double x) {
	if ( x <= 10.0 )	return 0.0;
	if ( x > 100.0 )	return 0.0;
	if ( x <= 50.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 10.0 ) / ( 50.0 - 10.0 ) );
	if ( x <= 70.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 50.0 ) / ( 70.0 - 50.0 ) );
	if ( x <= 100.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 70.0 ) / ( 100.0 - 70.0 ) );
}

double FunctionBlock_crashchance::membership_distance_verynearby(double x) {
	if ( x <= 0.0 )	return 1.0;
	if ( x > 15.0 )	return 0.0;
	if ( x <= 5.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 0.0 ) / ( 5.0 - 0.0 ) );
	if ( x <= 15.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 5.0 ) / ( 15.0 - 5.0 ) );
}

double FunctionBlock_crashchance::membership_sugested_decent(double x) {
	if ( x <= 20.0 )	return 0.0;
	if ( x > 60.0 )	return 0.0;
	if ( x <= 35.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 20.0 ) / ( 35.0 - 20.0 ) );
	if ( x <= 50.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 35.0 ) / ( 50.0 - 35.0 ) );
	if ( x <= 60.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 50.0 ) / ( 60.0 - 50.0 ) );
}

double FunctionBlock_crashchance::membership_sugested_fast(double x) {
	if ( x <= 55.0 )	return 0.0;
	if ( x > 80.0 )	return 0.0;
	if ( x <= 65.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 55.0 ) / ( 65.0 - 55.0 ) );
	if ( x <= 75.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 65.0 ) / ( 75.0 - 65.0 ) );
	if ( x <= 80.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 75.0 ) / ( 80.0 - 75.0 ) );
}

double FunctionBlock_crashchance::membership_sugested_slow(double x) {
	if ( x <= 8.0 )	return 0.0;
	if ( x > 25.0 )	return 0.0;
	if ( x <= 10.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 8.0 ) / ( 10.0 - 8.0 ) );
	if ( x <= 15.0 )	return 1.0 + ( 1.0 - 1.0 ) * ( ( x - 10.0 ) / ( 15.0 - 10.0 ) );
	if ( x <= 25.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 15.0 ) / ( 25.0 - 15.0 ) );
}

double FunctionBlock_crashchance::membership_sugested_veryfast(double x) {
	if ( x <= 75.0 )	return 0.0;
	if ( x > 120.0 )	return 1.0;
	if ( x <= 120.0 )	return 0.0 + ( 1.0 - 0.0 ) * ( ( x - 75.0 ) / ( 120.0 - 75.0 ) );
}

double FunctionBlock_crashchance::membership_sugested_veryslow(double x) {
	if ( x <= 0.0 )	return 1.0;
	if ( x > 10.0 )	return 0.0;
	if ( x <= 10.0 )	return 1.0 + ( 0.0 - 1.0 ) * ( ( x - 0.0 ) / ( 10.0 - 0.0 ) );
}


// Print
void FunctionBlock_crashchance::print() {
	printf("Function block crashchance:\n");
	printf("	Input  %20s : %f\n", "distance" , distance);
	printf("	       %20s : %f\n", "distance_decent" , distance_decent);
	printf("	       %20s : %f\n", "distance_far" , distance_far);
	printf("	       %20s : %f\n", "distance_faraway" , distance_faraway);
	printf("	       %20s : %f\n", "distance_nearby" , distance_nearby);
	printf("	       %20s : %f\n", "distance_verynearby" , distance_verynearby);
	printf("	Output %20s : %f\n", "sugested" , sugested);
}

// Reset output
void FunctionBlock_crashchance::reset() {
	for( int i=0 ; i < 1000 ; i++ )	{ defuzzify_sugested[i] = 0.0; }
}

int main(int argc, char *argv[]) {
	// Create function blocks
	FunctionBlock_crashchance crashchance;

	double czas;
    double dystans;
    double predkosc;
    std::cout<<"Podaj interwal czasowy [s]:";
    std::cin>>czas;
	std::cout<<"Podaj odleglosc poczatkowa [m]:";
	std::cin>>dystans;

	while(dystans>=0){
    crashchance.distance = dystans;
    crashchance.calc();

    predkosc=crashchance.sugested;
    std::cout<<"Dla dystansu = "<<dystans<<"\tsugerowana predkosc = "<<predkosc<<std::endl;
    dystans= dystans - predkosc*czas;
    }

}
